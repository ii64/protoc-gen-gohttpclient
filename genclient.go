package main

import (
	"fmt"
	"strings"

	options "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var (
	// ioPackage      = protogen.GoImportPath("io")
	fmtPackage     = protogen.GoImportPath("fmt")
	bytesPackage   = protogen.GoImportPath("bytes")
	mimePackage    = protogen.GoImportPath("mime")
	strconvPackage = protogen.GoImportPath("strconv")
	ioutilPackage  = protogen.GoImportPath("io/ioutil")
	contextPackage = protogen.GoImportPath("context")
	urlPackage     = protogen.GoImportPath("net/url")
	httpPackage    = protogen.GoImportPath("net/http")
	jsonPackage    = protogen.GoImportPath("encoding/json")

	errorsPackage = protogen.GoImportPath("github.com/pkg/errors")

	grpcPackage = protogen.GoImportPath("google.golang.org/grpc")
	// protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protoPackage     = protogen.GoImportPath("github.com/golang/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
)

var (
	msgFieldIgnore = map[string][]string{}
)

func GenerateFile(p *protogen.Plugin, f *protogen.File) (*protogen.GeneratedFile, error) {
	shouldGenerate := false
	for _, service := range f.Services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			shouldGenerate = true
		}
	}

	if !shouldGenerate {
		return nil, nil
	}

	filename := f.GeneratedFilenamePrefix + ".httpclient.go"
	g := p.NewGeneratedFile(filename, f.GoImportPath)

	g.P("// Code generated by protoc-gen-gohttpclient ", genVersion, ". DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	g.P("package ", f.GoPackageName)

	generateErrors(g)

	for _, service := range f.Services {
		if err := generateService(g, service); err != nil {
			return nil, err
		}
	}

	for _, msg := range f.Messages {
		if err := generateMessageUtil(g, msg); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) (err error) {
	generateServiceClientInterface(g, service)
	generateServiceConstructor(g, service)

	for _, method := range service.Methods {
		if err = generateMethod(g, method); err != nil {
			return err
		}
	}
	return nil
}

func generateErrors(g *protogen.GeneratedFile) {
	g.P("var (")
	g.P("ErrMethodHasNoHTTPClientSupport = ", errorsPackage.Ident("New"), "(\"no google.api.http option for this method\")")
	g.P(")")
}

func generateServiceClientInterface(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("// ", service.GoName, "HTTPClient is the http client.")
	g.P("type ", service.GoName, "HTTPClient struct {")
	g.P("   baseURL", " string")
	g.P("   client", " *", httpPackage.Ident("Client"))
	g.P("}")
}

func generateServiceConstructor(g *protogen.GeneratedFile, service *protogen.Service) {
	funcName := "New" + service.GoName + "HTTPClient"
	g.P("// ", funcName, " returns ", service.GoName, "HTTPClient")
	g.P("func ", funcName, "(baseURL string, client *", httpPackage.Ident("Client"), ") *", service.GoName, "HTTPClient {")
	g.P("    if client == nil {")
	g.P("        client = ", httpPackage.Ident("DefaultClient"))
	g.P("    }")
	g.P("    return &", service.GoName, "HTTPClient{")
	g.P("        baseURL: baseURL,")
	g.P("        client: client,")
	g.P("    }")
	g.P("}")
}

func methodSub(g *protogen.GeneratedFile, method *protogen.Method, prefix string) (r string) {
	r = "func (c *" + method.Parent.GoName + "HTTPClient)" +
		method.GoName
	return r
}

// https://github.com/grpc-ecosystem/grpc-gateway/blob/master/internal/descriptor/services.go#L200
func extractAPIOptions(method *protogen.Method) (*options.HttpRule, error) {
	if method.Desc.Options() == nil {
		return nil, nil
	}
	if !proto.HasExtension(method.Desc.Options(), options.E_Http) {
		return nil, nil
	}
	ext := proto.GetExtension(method.Desc.Options(), options.E_Http)
	opts, ok := ext.(*options.HttpRule)
	if !ok {
		return nil, fmt.Errorf("extension is %T; want an HttpRule", ext)
	}
	return opts, nil
}

type Binding struct {
	Method     *protogen.Method
	PathImpl   *pathPattern
	Body       *bodySelector
	HTTPMethod string
}

// https://github.com/grpc-ecosystem/grpc-gateway/blob/master/internal/descriptor/services.go#L70
func newBinding(method *protogen.Method, opts *options.HttpRule) (*Binding, error) {
	var (
		httpMethod   string
		pathTemplate string
	)

	switch {
	case opts.GetGet() != "":
		httpMethod = "GET"
		pathTemplate = opts.GetGet()
		if opts.Body != "" {
			return nil, fmt.Errorf("must not set request body when http method is GET: %s", method.Desc.Name())
		}
	case opts.GetPut() != "":
		httpMethod = "PUT"
		pathTemplate = opts.GetPut()
	case opts.GetPost() != "":
		httpMethod = "POST"
		pathTemplate = opts.GetPost()
	case opts.GetDelete() != "":
		httpMethod = "DELETE"
		pathTemplate = opts.GetDelete()
	case opts.GetPatch() != "":
		httpMethod = "PATCH"
		pathTemplate = opts.GetPatch()
	case opts.GetCustom() != nil:
		custom := opts.GetCustom()
		httpMethod = custom.Kind
		pathTemplate = custom.Path
	default:
		fmt.Printf("No patternn specified in google.api.HttpRule: %s\n", method.Desc.Name())
		return nil, nil
	}

	pathParsed, err := pathParse(pathTemplate)
	if err != nil {
		return nil, err
	}

	bodyParsed, err := bodyParse(opts.Body)
	if err != nil {
		return nil, err
	}

	return &Binding{
		Method:     method,
		PathImpl:   pathParsed,
		Body:       bodyParsed,
		HTTPMethod: httpMethod,
	}, nil
}

func extractMessageField(msg *protogen.Message) (r map[string]*protogen.Field, order []string) {
	r = map[string]*protogen.Field{}
	// fix map key order inconsistency
	order = []string{}
	for i := 0; i < msg.Desc.Fields().Len(); i++ {
		k := string(msg.Fields[i].Desc.Name())
		r[k] = msg.Fields[i]
		order = append(order, k)
	}
	return
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) (err error) {
	g.P("// ", method.GoName, " returns ", method.Output.GoIdent.GoName)
	if method.Comments.Leading.String() != "" {
		g.P("//")
	}
	g.P(method.Comments.Leading, methodSub(g, method, ""),
		"(ctx ", contextPackage.Ident("Context"), ", ", "in *", method.Input.GoIdent.GoName, ", opts ...", grpcPackage.Ident("CallOption"), ")",
		" (out *", method.Output.GoIdent.GoName, ", err error)",
		"{")

	opts, err := extractAPIOptions(method)
	if err != nil || opts == nil {
		g.P("return nil, ErrMethodHasNoHTTPClientSupport")
	} else {
		var b *Binding
		if b, err = newBinding(method, opts); err != nil {
			return err
		}

		// field order is not used
		inputField, _ := extractMessageField(method.Input)

		body := "b"
		if b.HTTPMethod == "GET" {
			body = ""
		}
		if body != "" {
			g.P("var ", body, " []byte")
		}

		tmpI := 0
		genTmpVar := func() string {
			defer func() {
				tmpI++
			}()
			return fmt.Sprintf("tm%d", tmpI)
		}

		initBody := func() {
			if len(b.Body.field) > 0 {
				var field = inputField[b.Body.field]
				var targ = "in"
				if b.Body.field == "*" {
					targ = "in"
				} else {
					targ = "in." + field.GoName
				}
				// check if in is nil
				// check if supplied field is proto message
				if b.Body.field != "*" && field.Desc.Message() != nil {
					g.P("if b, err = ", protojsonPackage.Ident("Marshal"), "(", targ, "); err != nil {")
					g.P("return")
					g.P("}")
				} else {
					// primitive type
					g.P("if b, err = ", jsonPackage.Ident("Marshal"), "(", targ, "); err != nil {")
					g.P("return")
					g.P("}")
				}
			}
		}

		var p = b.PathImpl
		url := []string{}
		declVarNames := []string{}
		declVFields := []string{}
		elVFields := []func(){}
		elUrlExc := []func(){}
		for i, j, k := 0, 0, 0; i < len(p.base)+len(p.terms); i++ {
			var isMap = false
			for _, chk := range p.pathMap {
				if chk == i {
					isMap = true
					break
				}
			}
			if !isMap {
				url = append(url, "\""+p.base[j]+"\"")
				j++
			} else {
				// url = url + p.terms[k].term
				varName := fmt.Sprintf("f%d", i)
				url = append(url, varName)
				var t = p.terms[k]
				g.P("// ", fmt.Sprintf("%+#v", t))
				if len(t.term.injectPoint) > 0 && t.term.raw != "*" {
					// g.P("// ")
					var lines = []string{}
					var nextIgnore = false
					for i, point := range t.term.injectPoint {
						var varName2 string
						if strings.HasPrefix(point, "/") && !nextIgnore {
							varName2 = fmt.Sprintf("s%d", i)
							elUrlExc = append(elUrlExc, func() {
								g.P("", varName2, " = \"\"")
							})
							declVarNames = append(declVarNames, varName2)
							lines = append(lines, varName2)
						}
						if point != "" {
							nextIgnore = false
							lines = append(lines, "\""+point+"\"")
						}
						if strings.HasSuffix(point, "/") {
							varName2 = fmt.Sprintf("e%d", i)
							elUrlExc = append(elUrlExc, func() {
								g.P("", varName2, " = \"\"")
							})
							lines = append(lines, varName2)
							declVarNames = append(declVarNames, varName2)
							nextIgnore = true
						}
					}
					declVFields = append(declVFields, varName)
					elVFields = append(elVFields, func() {
						vals := strings.Join(lines, "+")
						if vals == "" {
							vals = "\"\"" // explicit
						}
						g.P("", varName, " = ", vals) //
					})
				} else {
					var f = inputField[t.term.fieldName]
					elVFields = append(elVFields, func() {
						g.P("// ", fmt.Sprintf("%+#v", f.Desc.Kind()), " | ", f.Desc.Message())
						var mod func(string) string
						mod = generateFieldModifier(g, genTmpVar, f.Desc.Kind(), true)
						g.P("", varName, " = ", mod("in."+f.GoName)) //
					})
					declVFields = append(declVFields, varName)
				}
				k++
			}
		}

		initBody() // init for request body
		// write sub-url
		if decl := append(declVarNames, declVFields...); len(decl) > 0 {
			g.P("var ", strings.Join(decl, ", "), " string") // declare first
			g.P("if in != nil {")                            // nil safety
			if len(elUrlExc) > 0 {
				g.P("var fc = ctx.Value(\"URL_MAP\")")
				g.P("if fc != nil {")
				g.P("if urlMap, ok := fc.([]string); ok {")
				for i, v := range declVarNames { // elUrlExc
					// f()
					g.P("", v, " = ", urlPackage.Ident("QueryEscape"), "(", "urlMap[", i, "]", ")")
				}
				g.P("}")
				g.P("}")
			}
			for _, f := range elVFields {
				f()
			}
			g.P("}")
		}

		g.P("var req *", httpPackage.Ident("Request"))
		urlAddt := strings.Join(url, "+")
		urlx := "c.baseURL"
		if urlAddt != "" {
			urlx = urlx + "+" + urlAddt
		}

		var bd = "nil"
		if body != "" {
			bd = fmt.Sprintf("%s%s%s%s", g.QualifiedGoIdent(bytesPackage.Ident("NewBuffer")), "(", body, ")")
		}
		g.P("req, err = ", httpPackage.Ident("NewRequest"), "(\"", b.HTTPMethod, "\", ", urlx, ", ", bd, ")")

		g.P("if err != nil {")
		g.P("return")
		g.P("}")

		if len(inputField) > 0 {
			// set query string
			g.P("req.URL.RawQuery = in.QueryString().Encode()")
		}

		if body != "" {
			g.P("req.Header.Set(\"Content-Type\", \"application/json\")")
		}

		g.P("req = req.WithContext(ctx)")
		g.P("var res *", httpPackage.Ident("Response"))

		// wip: using grpc.CallOption
		// g.P("for _, opt := range opts {")
		// g.P("")
		// g.P("}")

		g.P("if res, err = c.client.Do(req); err != nil {")
		g.P("return")
		g.P("}")
		g.P("defer res.Body.Close()")
		g.P("var rs ", method.Output.GoIdent.GoName)

		g.P("var body []byte")
		g.P("if body, err = ", ioutilPackage.Ident("ReadAll"), "(res.Body); err != nil {")
		g.P("  return")
		g.P("}")

		g.P("switch ct, _, _ := ", mimePackage.Ident("ParseMediaType"), "(res.Header.Get(\"Content-Type\")); ct {")
		g.P("case \"application/protobuf\", \"application/x-protobuf\":")
		g.P("  if err = ", protoPackage.Ident("Unmarshal"), "(body, &rs); err != nil {")
		g.P("    return")
		g.P("  }")
		g.P("case \"application/json\", \"application/vnd.api+json\":")
		g.P("  pj := ", protojsonPackage.Ident("UnmarshalOptions"), "{", genUnmarshalOptions, "}")
		g.P("  if err = pj.Unmarshal(body, &rs); err != nil {")
		g.P("    return")
		g.P("  }")
		g.P("default:")
		g.P("  return nil, ", fmtPackage.Ident("Errorf"), "(\"unknown response content type %q\", ct)")
		g.P("}")
		g.P("return &rs, nil")
	}
	g.P("}")
	return nil
}
